// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module FPToInt_s2_2(
  input         io_s1_raw_a_sign,
  input  [10:0] io_s1_raw_a_exp,
  input  [52:0] io_s1_raw_a_sig,
  input  [2:0]  io_s1_rm,
  input  [1:0]  io_s1_op,
  input         io_s1_sel_lpath,
                io_s1_exp_of,
                io_s1_iv_sel_max,
                io_s1_lpath_iv,
                io_s1_lpath_of,
  input  [3:0]  io_s1_lpath_shamt,
  input  [10:0] io_s1_rpath_shamt,
  output [63:0] io_result,
  output [4:0]  io_fflags
);

  wire [52:0] _rpath_rounder_io_out;	// @[FPToInt.scala:116:29]
  wire        _rpath_rounder_io_inexact;	// @[FPToInt.scala:116:29]
  wire        _rpath_rounder_io_cout;	// @[FPToInt.scala:116:29]
  wire        _rpath_rounder_io_r_up;	// @[FPToInt.scala:116:29]
  wire [53:0] _shiftRightJam_io_out;	// @[ShiftRightJam.scala:28:31]
  wire        _shiftRightJam_io_sticky;	// @[ShiftRightJam.scala:28:31]
  wire [67:0] _lpath_sig_shifted_T_1 = {15'h0, io_s1_raw_a_sig} << io_s1_lpath_shamt;	// @[FPToInt.scala:107:16]
  wire        rpath_of_rpath_exp_inc = _rpath_rounder_io_r_up & (&(_shiftRightJam_io_out[31:1]));	// @[FPToInt.scala:116:29, :131:{29,51,63}, ShiftRightJam.scala:28:31]
  wire        rpath_of_rpath_exp_eq_31 = io_s1_raw_a_exp == 11'h41E;	// @[FPToInt.scala:132:37]
  wire        iv = io_s1_exp_of | io_s1_sel_lpath & io_s1_lpath_of | ~io_s1_sel_lpath & ~(io_s1_op[1]) & (~io_s1_raw_a_sign & (io_s1_op[0] ? rpath_of_rpath_exp_eq_31 | io_s1_raw_a_exp == 11'h41D & rpath_of_rpath_exp_inc : rpath_of_rpath_exp_eq_31 & rpath_of_rpath_exp_inc) | io_s1_raw_a_sign & rpath_of_rpath_exp_eq_31 & ((|(_shiftRightJam_io_out[31:1])) | _rpath_rounder_io_r_up)) | io_s1_sel_lpath & io_s1_lpath_iv | ~io_s1_sel_lpath & ~(io_s1_op[0]) & io_s1_raw_a_sign & (|{_rpath_rounder_io_cout, _rpath_rounder_io_out});	// @[Cat.scala:33:92, FPToInt.scala:97:31, :98:29, :116:29, :128:{18,63}, :131:{29,51}, :132:37, :133:37, :134:{24,36,42}, :136:{23,43}, :137:23, :139:54, :140:{38,41}, :142:{5,35}, :150:{33,50,61}, :151:{29,42,57}, ShiftRightJam.scala:28:31]
  wire [63:0] int_abs = io_s1_sel_lpath ? _lpath_sig_shifted_T_1[63:0] : {10'h0, _rpath_rounder_io_cout, _rpath_rounder_io_out};	// @[Cat.scala:33:92, FPToInt.scala:107:{16,67}, :116:29, :154:20]
  ShiftRightJam_6 shiftRightJam (	// @[ShiftRightJam.scala:28:31]
    .io_in     ({io_s1_raw_a_sig, 1'h0}),	// @[Cat.scala:33:92]
    .io_shamt  (io_s1_rpath_shamt),
    .io_out    (_shiftRightJam_io_out),
    .io_sticky (_shiftRightJam_io_sticky)
  );
  RoundingUnit_28 rpath_rounder (	// @[FPToInt.scala:116:29]
    .io_in       (_shiftRightJam_io_out[53:1]),	// @[FPToInt.scala:117:48, ShiftRightJam.scala:28:31]
    .io_roundIn  (_shiftRightJam_io_out[0]),	// @[FPToInt.scala:118:48, ShiftRightJam.scala:28:31]
    .io_stickyIn (_shiftRightJam_io_sticky),	// @[ShiftRightJam.scala:28:31]
    .io_signIn   (io_s1_raw_a_sign),
    .io_rm       (io_s1_rm),
    .io_out      (_rpath_rounder_io_out),
    .io_inexact  (_rpath_rounder_io_inexact),
    .io_cout     (_rpath_rounder_io_cout),
    .io_r_up     (_rpath_rounder_io_r_up)
  );
  assign io_result = iv ? (io_s1_iv_sel_max ? (io_s1_op[1] ? {~(io_s1_op[0]), 63'h7FFFFFFFFFFFFFFF} : {32'h0, ~(io_s1_op[0]), 31'h7FFFFFFF}) : io_s1_op[1] ? {io_s1_op[0], 63'h0} : {32'h0, io_s1_op[0], 31'h0}) : (io_s1_raw_a_sign & io_s1_op[0] ? 64'h0 - int_abs : int_abs) & {{32{io_s1_op[1]}}, 32'hFFFFFFFF};	// @[Bitwise.scala:77:12, Cat.scala:33:92, FPToInt.scala:97:31, :98:29, :107:16, :128:18, :131:63, :140:38, :151:42, :154:20, :155:{16,28,46,65}, :160:39, :165:19, :167:8, :169:10, :170:10]
  assign io_fflags = {iv, 3'h0, ~iv & ~io_s1_sel_lpath & _rpath_rounder_io_inexact};	// @[Cat.scala:33:92, FPToInt.scala:116:29, :150:50, :151:42, :152:{12,30}]
endmodule

