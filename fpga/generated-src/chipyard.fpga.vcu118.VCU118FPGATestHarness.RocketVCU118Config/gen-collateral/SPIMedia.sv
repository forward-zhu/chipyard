// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module SPIMedia(
  input         clock,
                reset,
                io_port_dq_0_i,
                io_port_dq_1_i,
                io_port_dq_2_i,
                io_port_dq_3_i,
  input  [11:0] io_ctrl_sck_div,
  input         io_ctrl_sck_pol,
                io_ctrl_sck_pha,
  input  [7:0]  io_ctrl_dla_cssck,
                io_ctrl_dla_sckcs,
                io_ctrl_dla_intercs,
                io_ctrl_dla_interxfr,
  input         io_ctrl_cs_id,
                io_ctrl_cs_dflt_0,
  input  [11:0] io_ctrl_extradel_coarse,
  input  [4:0]  io_ctrl_sampledel_sd,
  input         io_link_tx_valid,
  input  [7:0]  io_link_tx_bits,
                io_link_cnt,
  input  [1:0]  io_link_fmt_proto,
  input         io_link_fmt_endian,
                io_link_fmt_iodir,
                io_link_cs_set,
                io_link_cs_clear,
  output        io_port_sck,
                io_port_dq_0_o,
                io_port_dq_0_ie,
                io_port_dq_0_oe,
                io_port_dq_1_o,
                io_port_dq_1_ie,
                io_port_dq_1_oe,
                io_port_dq_2_o,
                io_port_dq_2_ie,
                io_port_dq_2_oe,
                io_port_dq_3_o,
                io_port_dq_3_ie,
                io_port_dq_3_oe,
                io_port_cs_0,
                io_link_tx_ready,
                io_link_rx_valid,
  output [7:0]  io_link_rx_bits
);

  wire            _phy_io_op_ready;	// @[SPIMedia.scala:35:19]
  reg             cs_id;	// @[SPIMedia.scala:49:15]
  reg             cs_dflt_0;	// @[SPIMedia.scala:49:15]
  reg             cs_set;	// @[SPIMedia.scala:50:19]
  wire [1:0]      cs_active_mask = {1'h0, io_link_cs_set} << io_ctrl_cs_id;	// @[SPIBundle.scala:48:19, SPIMedia.scala:44:15]
  wire            cs_active_0 = io_ctrl_cs_dflt_0 ^ cs_active_mask[0];	// @[SPIBundle.scala:48:19, :49:33]
  reg             clear;	// @[SPIMedia.scala:54:18]
  reg             cs_assert;	// @[SPIMedia.scala:55:22]
  wire            cs_deassert = clear | cs_active_0 != cs_dflt_0;	// @[SPIBundle.scala:49:33, SPIMedia.scala:49:15, :52:37, :54:18, :56:27]
  reg  [1:0]      state;	// @[SPIMedia.scala:71:18]
  wire            _T = state == 2'h0;	// @[SPIMedia.scala:71:18, :73:18]
  wire            _GEN = _T & cs_assert;	// @[SPIMedia.scala:43:14, :55:22, :73:18, :75:24, :76:28]
  wire            _T_2 = state == 2'h1;	// @[SPIMedia.scala:71:18, :73:18, :88:19]
  wire            _GEN_0 = _T ? ~cs_assert | cs_deassert | io_link_tx_valid : ~_T_2 | (|io_ctrl_dla_interxfr);	// @[SPIMedia.scala:42:12, :55:22, :56:27, :60:42, :73:18, :75:24, :76:28, :109:16]
  wire            _T_4 = state == 2'h2;	// @[SPIMedia.scala:71:18, :73:18, :79:19]
  wire [3:0][7:0] _GEN_1 = {{io_link_cnt}, {io_ctrl_dla_intercs}, {io_ctrl_dla_interxfr}, {cs_assert ? (cs_deassert ? io_ctrl_dla_sckcs : io_link_cnt) : io_link_tx_valid ? io_ctrl_dla_cssck : 8'h0}};	// @[SPIMedia.scala:45:15, :55:22, :56:27, :73:18, :75:24, :76:28, :77:23, :91:38, :93:21, :101:21, :110:19, :118:19]
  wire [1:0]      mask = {1'h0, cs_set} << cs_id;	// @[SPIBundle.scala:48:19, SPIMedia.scala:44:15, :49:15, :50:19]
  wire            _GEN_2 = io_link_tx_valid & _phy_io_op_ready;	// @[SPIMedia.scala:35:19, :55:22, :91:38, :94:25, :95:21]
  wire            _GEN_3 = _T_4 & _phy_io_op_ready;	// @[SPIMedia.scala:35:19, :49:15, :73:18, :122:23, :123:17]
  always @(posedge clock) begin
    if (~_T | cs_assert | io_link_tx_valid) begin	// @[SPIMedia.scala:49:15, :50:19, :55:22, :73:18, :75:24]
    end
    else	// @[SPIMedia.scala:49:15, :73:18, :75:24]
      cs_id <= io_ctrl_cs_id;	// @[SPIMedia.scala:49:15]
    if (_T) begin	// @[SPIMedia.scala:73:18]
      if (cs_assert) begin	// @[SPIMedia.scala:55:22]
      end
      else if (io_link_tx_valid) begin
        if (_phy_io_op_ready)	// @[SPIMedia.scala:35:19]
          cs_dflt_0 <= cs_active_0;	// @[SPIBundle.scala:49:33, SPIMedia.scala:49:15]
      end
      else
        cs_dflt_0 <= io_ctrl_cs_dflt_0;	// @[SPIMedia.scala:49:15]
    end
    else	// @[SPIMedia.scala:73:18]
      cs_dflt_0 <= ~_T_2 & _GEN_3 & mask[0] ^ cs_dflt_0;	// @[SPIBundle.scala:48:19, SPIMedia.scala:42:12, :49:15, :73:18, :109:16, :122:23, :123:17]
    if (~_T | cs_assert | ~_GEN_2) begin	// @[SPIMedia.scala:50:19, :55:22, :73:18, :75:24, :91:38, :94:25, :95:21]
    end
    else	// @[SPIMedia.scala:50:19, :73:18, :75:24]
      cs_set <= io_link_cs_set;	// @[SPIMedia.scala:50:19]
    if (reset) begin
      clear <= 1'h0;	// @[SPIMedia.scala:44:15, :54:18]
      cs_assert <= 1'h0;	// @[SPIMedia.scala:44:15, :55:22]
      state <= 2'h0;	// @[SPIMedia.scala:71:18]
    end
    else begin
      clear <= (_T | _T_2 | ~_T_4) & (clear | io_link_cs_clear & cs_assert);	// @[SPIMedia.scala:54:18, :55:22, :58:{9,18,39}, :73:18, :120:17]
      if (_T) begin	// @[SPIMedia.scala:73:18]
        cs_assert <= ~cs_assert & _GEN_2 | cs_assert;	// @[SPIMedia.scala:42:12, :55:22, :75:24, :76:28, :91:38, :94:25, :95:21]
        if (cs_assert) begin	// @[SPIMedia.scala:55:22]
          if (cs_deassert) begin	// @[SPIMedia.scala:56:27]
            if (_phy_io_op_ready)	// @[SPIMedia.scala:35:19]
              state <= 2'h2;	// @[SPIMedia.scala:71:18, :79:19]
          end
          else if (_phy_io_op_ready & _GEN_0)	// @[Decoupled.scala:51:35, SPIMedia.scala:35:19, :73:18, :75:24]
            state <= 2'h1;	// @[SPIMedia.scala:71:18, :88:19]
        end
      end
      else begin	// @[SPIMedia.scala:73:18]
        cs_assert <= (_T_2 | ~_T_4) & cs_assert;	// @[SPIMedia.scala:55:22, :73:18, :120:17]
        if (_T_2 ? _phy_io_op_ready | ~(|io_ctrl_dla_interxfr) : _GEN_3)	// @[SPIMedia.scala:35:19, :49:15, :60:42, :71:18, :73:18, :111:{22,37}, :112:15, :122:23, :123:17, :124:15]
          state <= 2'h0;	// @[SPIMedia.scala:71:18]
      end
    end
  end // always @(posedge)
  `ifndef SYNTHESIS
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM_0 = `RANDOM;
        cs_id = _RANDOM_0[0];	// @[SPIMedia.scala:49:15]
        cs_dflt_0 = _RANDOM_0[1];	// @[SPIMedia.scala:49:15]
        cs_set = _RANDOM_0[2];	// @[SPIMedia.scala:49:15, :50:19]
        clear = _RANDOM_0[3];	// @[SPIMedia.scala:49:15, :54:18]
        cs_assert = _RANDOM_0[4];	// @[SPIMedia.scala:49:15, :55:22]
        state = _RANDOM_0[6:5];	// @[SPIMedia.scala:49:15, :71:18]
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  SPIPhysical phy (	// @[SPIMedia.scala:35:19]
    .clock                   (clock),
    .reset                   (reset),
    .io_port_dq_0_i          (io_port_dq_0_i),
    .io_port_dq_1_i          (io_port_dq_1_i),
    .io_port_dq_2_i          (io_port_dq_2_i),
    .io_port_dq_3_i          (io_port_dq_3_i),
    .io_ctrl_sck_div         (io_ctrl_sck_div),
    .io_ctrl_sck_pol         (io_ctrl_sck_pol),
    .io_ctrl_sck_pha         (io_ctrl_sck_pha),
    .io_ctrl_fmt_proto       (io_link_fmt_proto),
    .io_ctrl_fmt_endian      (io_link_fmt_endian),
    .io_ctrl_fmt_iodir       (io_link_fmt_iodir),
    .io_ctrl_extradel_coarse (io_ctrl_extradel_coarse),
    .io_ctrl_sampledel_sd    (io_ctrl_sampledel_sd),
    .io_op_valid             (_GEN_0),	// @[SPIMedia.scala:73:18, :75:24]
    .io_op_bits_fn           (~_GEN | cs_deassert),	// @[SPIMedia.scala:43:14, :56:27, :73:18, :75:24, :76:28]
    .io_op_bits_stb          (_T ? (cs_assert ? ~cs_deassert : ~io_link_tx_valid) : ~_T_2 & _T_4),	// @[SPIMedia.scala:42:12, :44:15, :55:22, :56:27, :73:18, :75:24, :76:28, :83:23, :91:38, :102:21, :109:16]
    .io_op_bits_cnt          (_GEN_1[state]),	// @[SPIMedia.scala:45:15, :71:18, :73:18, :75:24, :110:19, :118:19]
    .io_op_bits_data         (io_link_tx_bits),
    .io_port_sck             (io_port_sck),
    .io_port_dq_0_o          (io_port_dq_0_o),
    .io_port_dq_0_ie         (io_port_dq_0_ie),
    .io_port_dq_0_oe         (io_port_dq_0_oe),
    .io_port_dq_1_o          (io_port_dq_1_o),
    .io_port_dq_1_ie         (io_port_dq_1_ie),
    .io_port_dq_1_oe         (io_port_dq_1_oe),
    .io_port_dq_2_o          (io_port_dq_2_o),
    .io_port_dq_2_ie         (io_port_dq_2_ie),
    .io_port_dq_2_oe         (io_port_dq_2_oe),
    .io_port_dq_3_o          (io_port_dq_3_o),
    .io_port_dq_3_ie         (io_port_dq_3_ie),
    .io_port_dq_3_oe         (io_port_dq_3_oe),
    .io_op_ready             (_phy_io_op_ready),
    .io_rx_valid             (io_link_rx_valid),
    .io_rx_bits              (io_link_rx_bits)
  );
  assign io_port_cs_0 = cs_dflt_0;	// @[SPIMedia.scala:49:15]
  assign io_link_tx_ready = _GEN & ~cs_deassert & _phy_io_op_ready;	// @[SPIMedia.scala:35:19, :43:14, :44:15, :56:27, :67:20, :73:18, :75:24, :76:28, :83:23]
endmodule

