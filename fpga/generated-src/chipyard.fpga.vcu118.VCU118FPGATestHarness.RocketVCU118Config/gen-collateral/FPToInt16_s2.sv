// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module FPToInt16_s2(
  input         io_s1_raw_a_sign,
  input  [7:0]  io_s1_raw_a_exp,
  input  [23:0] io_s1_raw_a_sig,
  input  [2:0]  io_s1_rm,
  input  [1:0]  io_s1_op,
  input         io_s1_sel_lpath,
                io_s1_exp_of,
                io_s1_iv_sel_max,
  input  [7:0]  io_s1_rpath_shamt,
  output [63:0] io_result,
  output [4:0]  io_fflags
);

  wire [15:0] _rpath_rounder_io_out;	// @[FPToInt16.scala:126:29]
  wire        _rpath_rounder_io_inexact;	// @[FPToInt16.scala:126:29]
  wire        _rpath_rounder_io_cout;	// @[FPToInt16.scala:126:29]
  wire        _rpath_rounder_io_r_up;	// @[FPToInt16.scala:126:29]
  wire [24:0] _shiftRightJam_io_out;	// @[ShiftRightJam.scala:28:31]
  wire        _shiftRightJam_io_sticky;	// @[ShiftRightJam.scala:28:31]
  wire        rpath_exp_inc = _rpath_rounder_io_r_up & (&(_shiftRightJam_io_out[23:9]));	// @[FPToInt16.scala:126:29, :140:{27,49,61}, ShiftRightJam.scala:28:31]
  wire        rpath_exp_eq_15 = io_s1_raw_a_exp == 8'h8E;	// @[FPToInt16.scala:141:35]
  wire        iv = io_s1_exp_of | ~io_s1_sel_lpath & ~(io_s1_op[1]) & (~io_s1_raw_a_sign & (io_s1_op[0] ? rpath_exp_eq_15 | io_s1_raw_a_exp == 8'h8D & rpath_exp_inc : rpath_exp_eq_15 & rpath_exp_inc) | io_s1_raw_a_sign & rpath_exp_eq_15 & ((|(_shiftRightJam_io_out[23:9])) | _rpath_rounder_io_r_up)) | ~io_s1_sel_lpath & ~(io_s1_op[0]) & io_s1_raw_a_sign & (|{_rpath_rounder_io_cout, _rpath_rounder_io_out});	// @[Cat.scala:33:92, FPToInt16.scala:107:31, :108:29, :126:29, :138:{18,63}, :140:{27,49}, :141:35, :142:35, :143:{22,34,40}, :145:{21,41}, :146:21, :148:52, :149:{36,39}, :151:{18,48}, :157:{50,61}, :158:{42,57}, ShiftRightJam.scala:28:31]
  wire [15:0] _int_T_4 = io_s1_sel_lpath ? io_s1_raw_a_sig[15:0] : _rpath_rounder_io_out;	// @[FPToInt16.scala:117:67, :126:29, :161:20]
  ShiftRightJam_4 shiftRightJam (	// @[ShiftRightJam.scala:28:31]
    .io_in     ({io_s1_raw_a_sig, 1'h0}),	// @[Cat.scala:33:92]
    .io_shamt  (io_s1_rpath_shamt),
    .io_out    (_shiftRightJam_io_out),
    .io_sticky (_shiftRightJam_io_sticky)
  );
  RoundingUnit_29 rpath_rounder (	// @[FPToInt16.scala:126:29]
    .io_in       (_shiftRightJam_io_out[24:9]),	// @[FPToInt16.scala:127:48, ShiftRightJam.scala:28:31]
    .io_roundIn  (_shiftRightJam_io_out[8]),	// @[FPToInt16.scala:128:{53,62}, ShiftRightJam.scala:28:31]
    .io_stickyIn (_shiftRightJam_io_sticky | (|(_shiftRightJam_io_out[7:0]))),	// @[FPToInt16.scala:129:{45,70,75}, ShiftRightJam.scala:28:31]
    .io_signIn   (io_s1_raw_a_sign),
    .io_rm       (io_s1_rm),
    .io_out      (_rpath_rounder_io_out),
    .io_inexact  (_rpath_rounder_io_inexact),
    .io_cout     (_rpath_rounder_io_cout),
    .io_r_up     (_rpath_rounder_io_r_up)
  );
  assign io_result = iv ? (io_s1_iv_sel_max ? (io_s1_op[1] ? {~(io_s1_op[0]), 63'h7FFFFFFFFFFFFFFF} : {48'h0, ~(io_s1_op[0]), 15'h7FFF}) : io_s1_op[1] ? {io_s1_op[0], 63'h0} : {48'h0, io_s1_op[0], 15'h0}) : {48'h0, io_s1_raw_a_sign & io_s1_op[0] ? 16'h0 - _int_T_4 : _int_T_4};	// @[Cat.scala:33:92, FPToInt16.scala:107:31, :108:29, :138:18, :140:61, :149:36, :158:42, :161:20, :162:{16,28,46}, :168:39, :175:19, :177:8, :179:10, :180:10]
  assign io_fflags = {iv, 3'h0, ~iv & ~io_s1_sel_lpath & _rpath_rounder_io_inexact};	// @[Cat.scala:33:92, FPToInt16.scala:126:29, :157:50, :158:42, :159:{12,30}]
endmodule

