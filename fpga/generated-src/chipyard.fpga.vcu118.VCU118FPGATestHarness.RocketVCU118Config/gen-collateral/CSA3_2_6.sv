// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module CSA3_2_6(
  input  [12:0] io_in_0,
                io_in_1,
                io_in_2,
  output [12:0] io_out_0,
                io_out_1
);

  wire a_xor_b = io_in_0[0] ^ io_in_1[0];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_1 = io_in_0[1] ^ io_in_1[1];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_2 = io_in_0[2] ^ io_in_1[2];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_3 = io_in_0[3] ^ io_in_1[3];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_4 = io_in_0[4] ^ io_in_1[4];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_5 = io_in_0[5] ^ io_in_1[5];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_6 = io_in_0[6] ^ io_in_1[6];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_7 = io_in_0[7] ^ io_in_1[7];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_8 = io_in_0[8] ^ io_in_1[8];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_9 = io_in_0[9] ^ io_in_1[9];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_10 = io_in_0[10] ^ io_in_1[10];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_11 = io_in_0[11] ^ io_in_1[11];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  wire a_xor_b_12 = io_in_0[12] ^ io_in_1[12];	// @[DivUtils.scala:107:{32,45}, :108:21, FDIV.scala:677:{32,45}, :678:21]
  assign io_out_0 = {a_xor_b_12 ^ io_in_2[12], a_xor_b_11 ^ io_in_2[11], a_xor_b_10 ^ io_in_2[10], a_xor_b_9 ^ io_in_2[9], a_xor_b_8 ^ io_in_2[8], a_xor_b_7 ^ io_in_2[7], a_xor_b_6 ^ io_in_2[6], a_xor_b_5 ^ io_in_2[5], a_xor_b_4 ^ io_in_2[4], a_xor_b_3 ^ io_in_2[3], a_xor_b_2 ^ io_in_2[2], a_xor_b_1 ^ io_in_2[1], a_xor_b ^ io_in_2[0]};	// @[Cat.scala:33:92, DivUtils.scala:107:58, :108:21, :110:23, FDIV.scala:677:58, :678:21, :680:23]
  assign io_out_1 = {io_in_0[12] & io_in_1[12] | a_xor_b_12 & io_in_2[12], io_in_0[11] & io_in_1[11] | a_xor_b_11 & io_in_2[11], io_in_0[10] & io_in_1[10] | a_xor_b_10 & io_in_2[10], io_in_0[9] & io_in_1[9] | a_xor_b_9 & io_in_2[9], io_in_0[8] & io_in_1[8] | a_xor_b_8 & io_in_2[8], io_in_0[7] & io_in_1[7] | a_xor_b_7 & io_in_2[7], io_in_0[6] & io_in_1[6] | a_xor_b_6 & io_in_2[6], io_in_0[5] & io_in_1[5] | a_xor_b_5 & io_in_2[5], io_in_0[4] & io_in_1[4] | a_xor_b_4 & io_in_2[4], io_in_0[3] & io_in_1[3] | a_xor_b_3 & io_in_2[3], io_in_0[2] & io_in_1[2] | a_xor_b_2 & io_in_2[2], io_in_0[1] & io_in_1[1] | a_xor_b_1 & io_in_2[1], io_in_0[0] & io_in_1[0] | a_xor_b & io_in_2[0]};	// @[Cat.scala:33:92, DivUtils.scala:107:{32,45,58}, :108:21, :109:21, :111:{24,35}, FDIV.scala:677:{32,45,58}, :678:21, :679:21, :681:{24,35}]
endmodule

