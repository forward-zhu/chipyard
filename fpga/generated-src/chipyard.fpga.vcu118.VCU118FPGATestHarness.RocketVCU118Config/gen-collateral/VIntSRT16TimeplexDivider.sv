// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module VIntSRT16TimeplexDivider(
  input         clock,
                reset,
                io_in_valid,
  input  [63:0] io_in_bits_vs1,
                io_in_bits_vs2,
  input  [5:0]  io_in_bits_uop_ctrl_funct6,
  input  [2:0]  io_in_bits_uop_info_vsew,
  input  [63:0] io_in_bits_uop_maskKeep,
                io_in_bits_uop_maskOff,
  output        io_in_ready,
                io_out_valid,
  output [63:0] io_out_bits_vd,
                io_out_bits_uop_maskKeep,
                io_out_bits_uop_maskOff
);

  wire             _m_io_in_ready;	// @[VIntDiv.scala:33:17]
  wire             _m_io_out_valid;	// @[VIntDiv.scala:33:17]
  wire [63:0]      _m_io_out_data;	// @[VIntDiv.scala:33:17]
  reg  [5:0]       uopReg_ctrl_funct6;	// @[Reg.scala:19:16]
  reg  [2:0]       uopReg_info_vsew;	// @[Reg.scala:19:16]
  reg  [63:0]      uopReg_maskKeep;	// @[Reg.scala:19:16]
  reg  [63:0]      uopReg_maskOff;	// @[Reg.scala:19:16]
  reg  [63:0]      a64Pre;	// @[Reg.scala:19:16]
  reg  [63:0]      d64Pre;	// @[Reg.scala:19:16]
  reg              busy;	// @[VIntDiv.scala:40:21]
  reg  [3:0]       uopsCntReg;	// @[Reg.scala:19:16]
  wire [3:0]       curUop = uopsCntReg - 4'h1;	// @[Reg.scala:19:16, VIntDiv.scala:56:24]
  wire [7:0][7:0]  _GEN = {{a64Pre[7:0]}, {a64Pre[15:8]}, {a64Pre[23:16]}, {a64Pre[31:24]}, {a64Pre[39:32]}, {a64Pre[47:40]}, {a64Pre[55:48]}, {a64Pre[63:56]}};	// @[DivUtils.scala:74:20, Reg.scala:19:16, VIntDiv.scala:62:55]
  wire [7:0]       _GEN_0 = _GEN[curUop[2:0]];	// @[DivUtils.scala:74:20, VIntDiv.scala:56:24, :67:38]
  wire [3:0][15:0] _GEN_1 = {{a64Pre[15:0]}, {a64Pre[31:16]}, {a64Pre[47:32]}, {a64Pre[63:48]}};	// @[DivUtils.scala:74:20, Reg.scala:19:16, VIntDiv.scala:62:55]
  wire [15:0]      _GEN_2 = _GEN_1[curUop[1:0]];	// @[DivUtils.scala:74:20, VIntDiv.scala:56:24, :68:40]
  wire [31:0]      _GEN_3 = curUop[0] ? a64Pre[31:0] : a64Pre[63:32];	// @[DivUtils.scala:74:20, Reg.scala:19:16, VIntDiv.scala:56:24, :62:55, :69:40]
  wire [7:0][7:0]  _GEN_4 = {{d64Pre[7:0]}, {d64Pre[15:8]}, {d64Pre[23:16]}, {d64Pre[31:24]}, {d64Pre[39:32]}, {d64Pre[47:40]}, {d64Pre[55:48]}, {d64Pre[63:56]}};	// @[DivUtils.scala:74:20, Reg.scala:19:16, VIntDiv.scala:62:55]
  wire [7:0]       _GEN_5 = _GEN_4[curUop[2:0]];	// @[DivUtils.scala:74:20, VIntDiv.scala:56:24, :67:38]
  wire [3:0][15:0] _GEN_6 = {{d64Pre[15:0]}, {d64Pre[31:16]}, {d64Pre[47:32]}, {d64Pre[63:48]}};	// @[DivUtils.scala:74:20, Reg.scala:19:16, VIntDiv.scala:62:55]
  wire [15:0]      _GEN_7 = _GEN_6[curUop[1:0]];	// @[DivUtils.scala:74:20, VIntDiv.scala:56:24, :68:40]
  wire [31:0]      _GEN_8 = curUop[0] ? d64Pre[31:0] : d64Pre[63:32];	// @[DivUtils.scala:74:20, Reg.scala:19:16, VIntDiv.scala:56:24, :62:55, :69:40]
  reg              mValidReg;	// @[VIntDiv.scala:85:26]
  reg  [3:0]       resultCntReg;	// @[Reg.scala:19:16]
  wire [3:0]       curResult = resultCntReg - 4'h1;	// @[Reg.scala:19:16, VIntDiv.scala:88:29]
  wire             resultComplete = curResult == 4'h0 & mValidReg;	// @[Mux.scala:81:58, VIntDiv.scala:85:26, :88:29, :89:{31,39}]
  reg  [63:0]      resultRegs_0;	// @[VIntDiv.scala:91:23]
  reg  [63:0]      resultRegs_1;	// @[VIntDiv.scala:91:23]
  reg  [63:0]      resultRegs_2;	// @[VIntDiv.scala:91:23]
  wire [63:0]      partialResult_0 = {_m_io_out_data[7:0], resultRegs_0[63:8]};	// @[Cat.scala:33:92, VIntDiv.scala:33:17, :91:23, :93:{40,62}]
  wire [63:0]      partialResult_1 = {_m_io_out_data[15:0], resultRegs_1[63:16]};	// @[Cat.scala:33:92, VIntDiv.scala:33:17, :91:23, :94:{40,63}]
  wire [63:0]      partialResult_2 = {_m_io_out_data[31:0], resultRegs_2[63:32]};	// @[Cat.scala:33:92, VIntDiv.scala:33:17, :91:23, :95:{40,63}]
  wire             _io_out_bits_vd_T = uopReg_info_vsew == 3'h0;	// @[Mux.scala:29:36, :81:61, Reg.scala:19:16]
  wire             _io_out_bits_vd_T_1 = uopReg_info_vsew == 3'h1;	// @[Mux.scala:29:36, :81:61, Reg.scala:19:16]
  wire             _io_out_bits_vd_T_2 = uopReg_info_vsew == 3'h2;	// @[Mux.scala:29:36, :81:61, Reg.scala:19:16]
  wire             _io_out_bits_vd_T_3 = uopReg_info_vsew == 3'h3;	// @[Mux.scala:29:36, :81:61, Reg.scala:19:16]
  wire             in_fire = io_in_valid & ~busy;	// @[VIntDiv.scala:21:29, :40:21, :41:8]
  wire [3:0]       _uopsTotal_T_1 = {io_in_bits_uop_info_vsew == 3'h0, 3'h0};	// @[Mux.scala:81:{58,61}]
  wire             _uopsTotal_T_2 = io_in_bits_uop_info_vsew == 3'h1;	// @[Mux.scala:81:61]
  wire             _uopsTotal_T_4 = io_in_bits_uop_info_vsew == 3'h2;	// @[Mux.scala:81:61]
  wire             _uopsTotal_T_6 = io_in_bits_uop_info_vsew == 3'h3;	// @[Mux.scala:81:61]
  always @(posedge clock) begin
    if (in_fire) begin	// @[VIntDiv.scala:21:29]
      uopReg_ctrl_funct6 <= io_in_bits_uop_ctrl_funct6;	// @[Reg.scala:19:16]
      uopReg_info_vsew <= io_in_bits_uop_info_vsew;	// @[Reg.scala:19:16]
      uopReg_maskKeep <= io_in_bits_uop_maskKeep;	// @[Reg.scala:19:16]
      uopReg_maskOff <= io_in_bits_uop_maskOff;	// @[Reg.scala:19:16]
      a64Pre <= io_in_bits_vs2;	// @[Reg.scala:19:16]
      d64Pre <= io_in_bits_vs1;	// @[Reg.scala:19:16]
    end
    if (in_fire | _m_io_in_ready) begin	// @[VIntDiv.scala:21:29, :33:17, :54:47]
      if (in_fire) begin	// @[VIntDiv.scala:21:29]
        if (_uopsTotal_T_6)	// @[Mux.scala:81:61]
          uopsCntReg <= 4'h1;	// @[Mux.scala:81:58, Reg.scala:19:16]
        else if (_uopsTotal_T_4)	// @[Mux.scala:81:61]
          uopsCntReg <= 4'h2;	// @[Mux.scala:81:58, Reg.scala:19:16]
        else if (_uopsTotal_T_2)	// @[Mux.scala:81:61]
          uopsCntReg <= 4'h4;	// @[Mux.scala:81:58, Reg.scala:19:16]
        else	// @[Mux.scala:81:61]
          uopsCntReg <= _uopsTotal_T_1;	// @[Mux.scala:81:58, Reg.scala:19:16]
      end
      else	// @[VIntDiv.scala:21:29]
        uopsCntReg <= curUop;	// @[Reg.scala:19:16, VIntDiv.scala:56:24]
    end
    mValidReg <= _m_io_out_valid;	// @[VIntDiv.scala:33:17, :85:26]
    if (in_fire | mValidReg) begin	// @[VIntDiv.scala:21:29, :85:26, :86:51]
      if (in_fire) begin	// @[VIntDiv.scala:21:29]
        if (_uopsTotal_T_6)	// @[Mux.scala:81:61]
          resultCntReg <= 4'h1;	// @[Mux.scala:81:58, Reg.scala:19:16]
        else if (_uopsTotal_T_4)	// @[Mux.scala:81:61]
          resultCntReg <= 4'h2;	// @[Mux.scala:81:58, Reg.scala:19:16]
        else if (_uopsTotal_T_2)	// @[Mux.scala:81:61]
          resultCntReg <= 4'h4;	// @[Mux.scala:81:58, Reg.scala:19:16]
        else	// @[Mux.scala:81:61]
          resultCntReg <= _uopsTotal_T_1;	// @[Mux.scala:81:58, Reg.scala:19:16]
      end
      else	// @[VIntDiv.scala:21:29]
        resultCntReg <= curResult;	// @[Reg.scala:19:16, VIntDiv.scala:88:29]
    end
    if (mValidReg) begin	// @[VIntDiv.scala:85:26]
      resultRegs_0 <= partialResult_0;	// @[Cat.scala:33:92, VIntDiv.scala:91:23]
      resultRegs_1 <= partialResult_1;	// @[Cat.scala:33:92, VIntDiv.scala:91:23]
      resultRegs_2 <= partialResult_2;	// @[Cat.scala:33:92, VIntDiv.scala:91:23]
    end
    if (reset)
      busy <= 1'h0;	// @[VIntDiv.scala:40:21]
    else
      busy <= ~busy & in_fire | ~(busy & resultComplete) & busy;	// @[VIntDiv.scala:21:29, :40:21, :41:{8,14,26}, :42:10, :43:{20,39}, :44:10, :89:39]
  end // always @(posedge)
  `ifndef SYNTHESIS
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;
    logic [31:0] _RANDOM_1;
    logic [31:0] _RANDOM_2;
    logic [31:0] _RANDOM_3;
    logic [31:0] _RANDOM_4;
    logic [31:0] _RANDOM_5;
    logic [31:0] _RANDOM_6;
    logic [31:0] _RANDOM_7;
    logic [31:0] _RANDOM_8;
    logic [31:0] _RANDOM_9;
    logic [31:0] _RANDOM_10;
    logic [31:0] _RANDOM_11;
    logic [31:0] _RANDOM_12;
    logic [31:0] _RANDOM_13;
    logic [31:0] _RANDOM_14;
    logic [31:0] _RANDOM_15;
    logic [31:0] _RANDOM_16;
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM_0 = `RANDOM;
        _RANDOM_1 = `RANDOM;
        _RANDOM_2 = `RANDOM;
        _RANDOM_3 = `RANDOM;
        _RANDOM_4 = `RANDOM;
        _RANDOM_5 = `RANDOM;
        _RANDOM_6 = `RANDOM;
        _RANDOM_7 = `RANDOM;
        _RANDOM_8 = `RANDOM;
        _RANDOM_9 = `RANDOM;
        _RANDOM_10 = `RANDOM;
        _RANDOM_11 = `RANDOM;
        _RANDOM_12 = `RANDOM;
        _RANDOM_13 = `RANDOM;
        _RANDOM_14 = `RANDOM;
        _RANDOM_15 = `RANDOM;
        _RANDOM_16 = `RANDOM;
        uopReg_ctrl_funct6 = _RANDOM_0[21:16];	// @[Reg.scala:19:16]
        uopReg_info_vsew = _RANDOM_1[22:20];	// @[Reg.scala:19:16]
        uopReg_maskKeep = {_RANDOM_2[31:10], _RANDOM_3, _RANDOM_4[9:0]};	// @[Reg.scala:19:16]
        uopReg_maskOff = {_RANDOM_4[31:10], _RANDOM_5, _RANDOM_6[9:0]};	// @[Reg.scala:19:16]
        a64Pre = {_RANDOM_6[31:10], _RANDOM_7, _RANDOM_8[9:0]};	// @[Reg.scala:19:16]
        d64Pre = {_RANDOM_8[31:10], _RANDOM_9, _RANDOM_10[9:0]};	// @[Reg.scala:19:16]
        busy = _RANDOM_10[10];	// @[Reg.scala:19:16, VIntDiv.scala:40:21]
        uopsCntReg = _RANDOM_10[14:11];	// @[Reg.scala:19:16]
        mValidReg = _RANDOM_10[15];	// @[Reg.scala:19:16, VIntDiv.scala:85:26]
        resultCntReg = _RANDOM_10[19:16];	// @[Reg.scala:19:16]
        resultRegs_0 = {_RANDOM_10[31:20], _RANDOM_11, _RANDOM_12[19:0]};	// @[Reg.scala:19:16, VIntDiv.scala:91:23]
        resultRegs_1 = {_RANDOM_12[31:20], _RANDOM_13, _RANDOM_14[19:0]};	// @[VIntDiv.scala:91:23]
        resultRegs_2 = {_RANDOM_14[31:20], _RANDOM_15, _RANDOM_16[19:0]};	// @[VIntDiv.scala:91:23]
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  SRT16DividerDataModule m (	// @[VIntDiv.scala:33:17]
    .clock        (clock),
    .reset        (reset),
    .io_src_0     ((_io_out_bits_vd_T ? {{56{uopReg_ctrl_funct6[0] & _GEN_0[7]}}, _GEN_0} : 64'h0) | (_io_out_bits_vd_T_1 ? {{48{uopReg_ctrl_funct6[0] & _GEN_2[15]}}, _GEN_2} : 64'h0) | (_io_out_bits_vd_T_2 ? {{32{uopReg_ctrl_funct6[0] & _GEN_3[31]}}, _GEN_3} : 64'h0) | (_io_out_bits_vd_T_3 ? a64Pre : 64'h0)),	// @[Bitwise.scala:77:12, Cat.scala:33:92, DivUtils.scala:74:20, Mux.scala:27:73, :29:36, Reg.scala:19:16, VIntDiv.scala:31:36, :79:33]
    .io_src_1     ((_io_out_bits_vd_T ? {{56{uopReg_ctrl_funct6[0] & _GEN_5[7]}}, _GEN_5} : 64'h0) | (_io_out_bits_vd_T_1 ? {{48{uopReg_ctrl_funct6[0] & _GEN_7[15]}}, _GEN_7} : 64'h0) | (_io_out_bits_vd_T_2 ? {{32{uopReg_ctrl_funct6[0] & _GEN_8[31]}}, _GEN_8} : 64'h0) | (_io_out_bits_vd_T_3 ? d64Pre : 64'h0)),	// @[Bitwise.scala:77:12, Cat.scala:33:92, DivUtils.scala:74:20, Mux.scala:27:73, :29:36, Reg.scala:19:16, VIntDiv.scala:31:36, :79:33]
    .io_valid     (busy),	// @[VIntDiv.scala:40:21]
    .io_sign      (uopReg_ctrl_funct6[0]),	// @[Reg.scala:19:16, VIntDiv.scala:31:36]
    .io_isHi      (uopReg_ctrl_funct6[1]),	// @[Reg.scala:19:16, VIntDiv.scala:30:33]
    .io_in_ready  (_m_io_in_ready),
    .io_out_valid (_m_io_out_valid),
    .io_out_data  (_m_io_out_data)
  );
  assign io_in_ready = ~busy;	// @[VIntDiv.scala:40:21, :41:8]
  assign io_out_valid = resultComplete;	// @[VIntDiv.scala:89:39]
  assign io_out_bits_vd = (_io_out_bits_vd_T ? partialResult_0 : 64'h0) | (_io_out_bits_vd_T_1 ? partialResult_1 : 64'h0) | (_io_out_bits_vd_T_2 ? partialResult_2 : 64'h0) | (_io_out_bits_vd_T_3 ? _m_io_out_data : 64'h0);	// @[Cat.scala:33:92, Mux.scala:27:73, :29:36, VIntDiv.scala:33:17]
  assign io_out_bits_uop_maskKeep = uopReg_maskKeep;	// @[Reg.scala:19:16]
  assign io_out_bits_uop_maskOff = uopReg_maskOff;	// @[Reg.scala:19:16]
endmodule

