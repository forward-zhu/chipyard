// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module perm_RegFifo(
  input        clock,
               reset,
               io_rst,
               io_enq_valid,
  input  [7:0] io_enq_bits,
  input        io_deq_ready,
  output       io_deq_valid,
  output [7:0] io_deq_bits
);

  reg  [7:0]      memReg_0;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_1;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_2;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_3;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_4;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_5;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_6;	// @[PermFifo.scala:42:19]
  reg  [7:0]      memReg_7;	// @[PermFifo.scala:42:19]
  reg  [2:0]      readPtr;	// @[PermFifo.scala:30:25]
  reg  [2:0]      writePtr;	// @[PermFifo.scala:30:25]
  reg             emptyReg;	// @[PermFifo.scala:49:25]
  reg             fullReg;	// @[PermFifo.scala:50:24]
  wire [7:0][7:0] _GEN = {{memReg_7}, {memReg_6}, {memReg_5}, {memReg_4}, {memReg_3}, {memReg_2}, {memReg_1}, {memReg_0}};	// @[PermFifo.scala:42:19, :70:15]
  wire [2:0]      _nextVal_T_2 = readPtr + 3'h1;	// @[PermFifo.scala:30:25, :31:61, :58:22]
  wire [2:0]      _nextVal_T_5 = writePtr + 3'h1;	// @[PermFifo.scala:30:25, :31:61, :58:22]
  wire            incrRead = io_deq_ready & ~emptyReg;	// @[PermFifo.scala:49:25, :64:{21,24}]
  wire            incrWrite = io_enq_valid & ~fullReg;	// @[PermFifo.scala:50:24, :57:{21,24}]
  always @(posedge clock) begin
    if (incrWrite & writePtr == 3'h0)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_0 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & writePtr == 3'h1)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_1 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & writePtr == 3'h2)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_2 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & writePtr == 3'h3)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_3 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & writePtr == 3'h4)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_4 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & writePtr == 3'h5)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_5 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & writePtr == 3'h6)	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_6 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (incrWrite & (&writePtr))	// @[PermFifo.scala:30:25, :42:19, :57:{21,34}, :58:22]
      memReg_7 <= io_enq_bits;	// @[PermFifo.scala:42:19]
    if (reset) begin
      readPtr <= 3'h0;	// @[PermFifo.scala:30:25]
      writePtr <= 3'h0;	// @[PermFifo.scala:30:25]
      emptyReg <= 1'h1;	// @[PermFifo.scala:31:61, :49:25]
      fullReg <= 1'h0;	// @[PermFifo.scala:42:19, :50:24]
    end
    else begin
      if (io_rst) begin
        readPtr <= 3'h0;	// @[PermFifo.scala:30:25]
        writePtr <= 3'h0;	// @[PermFifo.scala:30:25]
      end
      else begin
        if (incrRead) begin	// @[PermFifo.scala:64:21]
          if (&readPtr)	// @[PermFifo.scala:30:25, :31:30]
            readPtr <= 3'h0;	// @[PermFifo.scala:30:25]
          else	// @[PermFifo.scala:31:30]
            readPtr <= _nextVal_T_2;	// @[PermFifo.scala:30:25, :31:61]
        end
        if (incrWrite) begin	// @[PermFifo.scala:57:21]
          if (&writePtr)	// @[PermFifo.scala:30:25, :31:30]
            writePtr <= 3'h0;	// @[PermFifo.scala:30:25]
          else	// @[PermFifo.scala:31:30]
            writePtr <= _nextVal_T_5;	// @[PermFifo.scala:30:25, :31:61]
        end
      end
      if (incrRead)	// @[PermFifo.scala:64:21]
        emptyReg <= ((&readPtr) ? 3'h0 : _nextVal_T_2) == writePtr;	// @[PermFifo.scala:30:25, :31:{22,30,61}, :49:25, :66:26]
      else	// @[PermFifo.scala:64:21]
        emptyReg <= ~incrWrite & (io_rst | emptyReg);	// @[PermFifo.scala:49:25, :52:16, :53:14, :57:{21,34}, :59:14]
      fullReg <= ~incrRead & (incrWrite ? ((&writePtr) ? 3'h0 : _nextVal_T_5) == readPtr : ~io_rst & fullReg);	// @[PermFifo.scala:30:25, :31:{22,30,61}, :50:24, :52:16, :54:13, :57:{21,34}, :60:{13,26}, :64:{21,35}, :65:13]
    end
  end // always @(posedge)
  `ifndef SYNTHESIS
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;
    logic [31:0] _RANDOM_1;
    logic [31:0] _RANDOM_2;
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM_0 = `RANDOM;
        _RANDOM_1 = `RANDOM;
        _RANDOM_2 = `RANDOM;
        memReg_0 = _RANDOM_0[7:0];	// @[PermFifo.scala:42:19]
        memReg_1 = _RANDOM_0[15:8];	// @[PermFifo.scala:42:19]
        memReg_2 = _RANDOM_0[23:16];	// @[PermFifo.scala:42:19]
        memReg_3 = _RANDOM_0[31:24];	// @[PermFifo.scala:42:19]
        memReg_4 = _RANDOM_1[7:0];	// @[PermFifo.scala:42:19]
        memReg_5 = _RANDOM_1[15:8];	// @[PermFifo.scala:42:19]
        memReg_6 = _RANDOM_1[23:16];	// @[PermFifo.scala:42:19]
        memReg_7 = _RANDOM_1[31:24];	// @[PermFifo.scala:42:19]
        readPtr = _RANDOM_2[2:0];	// @[PermFifo.scala:30:25]
        writePtr = _RANDOM_2[5:3];	// @[PermFifo.scala:30:25]
        emptyReg = _RANDOM_2[6];	// @[PermFifo.scala:30:25, :49:25]
        fullReg = _RANDOM_2[7];	// @[PermFifo.scala:30:25, :50:24]
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  assign io_deq_valid = ~emptyReg;	// @[PermFifo.scala:49:25, :64:24]
  assign io_deq_bits = _GEN[readPtr];	// @[PermFifo.scala:30:25, :70:15]
endmodule

