// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module FDIV(
  input         clock,
                reset,
  input  [31:0] io_a,
                io_b,
  input  [2:0]  io_rm,
  input         io_specialIO_in_valid,
                io_specialIO_out_ready,
                io_specialIO_isSqrt,
  output [31:0] io_result,
  output [4:0]  io_fflags,
  output        io_specialIO_in_ready,
                io_specialIO_out_valid
);

  wire [22:0] _rounder_io_out;	// @[FDIV.scala:320:23]
  wire        _rounder_io_inexact;	// @[FDIV.scala:320:23]
  wire        _rounder_io_cout;	// @[FDIV.scala:320:23]
  wire [26:0] _sqrtModule_io_rem;	// @[FDIV.scala:307:26]
  wire [25:0] _sqrtModule_io_res;	// @[FDIV.scala:307:26]
  wire [25:0] _sqrtModule_io_resM1;	// @[FDIV.scala:307:26]
  wire [27:0] _divModule_io_rem;	// @[FDIV.scala:300:25]
  wire [25:0] _divModule_io_quot;	// @[FDIV.scala:300:25]
  wire [25:0] _divModule_io_quotM1;	// @[FDIV.scala:300:25]
  wire [4:0]  _dLZC_clz_io_out;	// @[CLZ.scala:23:21]
  wire [4:0]  _aLZC_clz_io_out;	// @[CLZ.scala:23:21]
  reg  [5:0]  state;	// @[FDIV.scala:172:22]
  reg         outValidReg;	// @[FDIV.scala:173:28]
  reg         aSubReg;	// @[Reg.scala:19:16]
  reg         dSubReg;	// @[Reg.scala:19:16]
  reg         sqrtReg;	// @[Reg.scala:19:16]
  reg  [2:0]  rmReg;	// @[Reg.scala:19:16]
  reg         resSignReg;	// @[Reg.scala:19:16]
  reg  [23:0] aSigReg;	// @[Reg.scala:19:16]
  reg  [23:0] dSigReg;	// @[Reg.scala:19:16]
  reg  [8:0]  aExp;	// @[Reg.scala:19:16]
  reg  [8:0]  dExp;	// @[Reg.scala:19:16]
  reg         inv;	// @[Reg.scala:19:16]
  reg         inv_flag;	// @[Reg.scala:19:16]
  reg         dz;	// @[Reg.scala:19:16]
  reg         zero_div;	// @[Reg.scala:19:16]
  reg         div_inf;	// @[Reg.scala:19:16]
  reg         inf_div;	// @[Reg.scala:19:16]
  wire        sigCmp = aSigReg < dSigReg;	// @[FDIV.scala:259:24, Reg.scala:19:16]
  reg         subResReg;	// @[Reg.scala:19:16]
  reg  [4:0]  special_fflags;	// @[Reg.scala:19:16]
  reg  [7:0]  special_exp;	// @[Reg.scala:19:16]
  reg  [22:0] special_sig;	// @[Reg.scala:19:16]
  reg         skipIterReg;	// @[Reg.scala:19:16]
  reg         needShiftReg;	// @[Reg.scala:19:16]
  reg         oddIterReg;	// @[Reg.scala:19:16]
  reg  [3:0]  iterNumReg;	// @[Reg.scala:19:16]
  wire        finalIter = iterNumReg == 4'h0;	// @[FDIV.scala:217:20, :297:27, OneHot.scala:64:12, Reg.scala:19:16]
  wire [28:0] r = sqrtReg ? {{2{_sqrtModule_io_rem[26]}}, _sqrtModule_io_rem} : {_divModule_io_rem[27], _divModule_io_rem};	// @[Bitwise.scala:77:12, Cat.scala:33:92, FDIV.scala:130:20, :300:25, :307:26, :316:14, Reg.scala:19:16]
  wire [24:0] _GEN = r[28] ? (sqrtReg ? _sqrtModule_io_resM1[24:0] : _divModule_io_quotM1[24:0]) : sqrtReg ? _sqrtModule_io_res[24:0] : _divModule_io_quot[24:0];	// @[FDIV.scala:300:25, :307:26, :312:18, :313:20, :316:14, :317:{19,26}, Reg.scala:19:16]
  reg  [7:0]  combinedExpReg;	// @[Reg.scala:19:16]
  reg  [22:0] combinedSigReg;	// @[Reg.scala:19:16]
  reg  [4:0]  combinedFFlagsReg;	// @[Reg.scala:19:16]
  reg         combinedSignReg;	// @[Reg.scala:19:16]
  wire        _T_2 = state[0] & state[0] & io_specialIO_in_valid;	// @[FDIV.scala:172:22, :176:20, :207:{20,29}]
  wire        _T_9 = finalIter & state[3];	// @[FDIV.scala:172:22, :214:{25,33}, :297:27]
  wire        _T_12 = state[4] & io_specialIO_out_ready;	// @[FDIV.scala:172:22, :217:{20,31}]
  wire [54:0] _aSigNorm_T = {31'h0, aSigReg} << _aLZC_clz_io_out;	// @[CLZ.scala:23:21, FDIV.scala:239:23, Reg.scala:19:16]
  wire [54:0] _dSigNorm_T = {31'h0, dSigReg} << _dLZC_clz_io_out;	// @[CLZ.scala:23:21, FDIV.scala:239:23, :241:23, Reg.scala:19:16]
  wire        decode_a_isSubnormal = ~(|(io_a[30:23])) & (|(io_a[22:0]));	// @[package.scala:36:31, :38:31, :41:27, :45:46, :64:18, :65:18]
  wire        decode_a_isInf = (&(io_a[30:23])) & ~(|(io_a[22:0]));	// @[package.scala:37:31, :38:31, :44:27, :46:40, :64:18, :65:18]
  wire        decode_a_isZero = ~(|(io_a[30:23])) & ~(|(io_a[22:0]));	// @[package.scala:36:31, :38:31, :41:27, :44:27, :47:41, :64:18, :65:18]
  wire        decode_a_isNaN = (&(io_a[30:23])) & (|(io_a[22:0]));	// @[package.scala:37:31, :38:31, :48:40, :64:18, :65:18]
  wire        decode_b_isSubnormal = ~(|(io_b[30:23])) & (|(io_b[22:0]));	// @[package.scala:36:31, :38:31, :41:27, :45:46, :64:18, :65:18]
  wire        decode_b_isInf = (&(io_b[30:23])) & ~(|(io_b[22:0]));	// @[package.scala:37:31, :38:31, :44:27, :46:40, :64:18, :65:18]
  wire        decode_b_isZero = ~(|(io_b[30:23])) & ~(|(io_b[22:0]));	// @[package.scala:36:31, :38:31, :41:27, :44:27, :47:41, :64:18, :65:18]
  wire        decode_b_isNaN = (&(io_b[30:23])) & (|(io_b[22:0]));	// @[package.scala:37:31, :38:31, :48:40, :64:18, :65:18]
  wire        _inv_flag_T_5 = decode_a_isInf & decode_b_isInf;	// @[FDIV.scala:249:102, package.scala:46:40]
  wire        _inv_flag_T_6 = decode_b_isZero & decode_a_isZero;	// @[FDIV.scala:249:141, package.scala:47:41]
  wire [8:0]  _GEN_0 = aExp - 9'h7F;	// @[FDIV.scala:263:36, Reg.scala:19:16]
  wire [9:0]  finalExp = sqrtReg ? {{2{_GEN_0[8]}}, _GEN_0[8:1]} : {aExp[8], aExp} + ~{dExp[8], dExp} + {9'h0, ~sigCmp};	// @[Bitwise.scala:77:12, Cat.scala:33:92, FDIV.scala:130:20, :259:24, :261:{48,50,78,81}, :263:{36,70}, :264:21, Reg.scala:19:16]
  wire [9:0]  subResBits = finalExp + 10'h97;	// @[FDIV.scala:264:21, :266:27]
  wire [9:0]  _GEN_1 = finalExp + 10'h7E;	// @[FDIV.scala:264:21, :268:26]
  wire        subRes = _GEN_1[9] & ~(subResBits[9]);	// @[FDIV.scala:266:{27,77}, :268:{26,68,79,82}]
  wire [9:0]  _GEN_2 = ~finalExp + 10'h80;	// @[FDIV.scala:264:21, :267:{17,27}]
  wire        overflow = _GEN_2[9] & ~inv & ~dz & ~inf_div;	// @[FDIV.scala:267:{27,105}, :272:{28,36,40,43}, Reg.scala:19:16]
  wire        underflow_pre = subResBits[9] & ~inv & ~dz & ~zero_div & ~div_inf;	// @[FDIV.scala:266:{27,77}, :272:{28,36}, :273:{49,59,62}, Reg.scala:19:16]
  wire        skipIter = overflow | underflow_pre | inv | dz | subResBits[9] | zero_div | div_inf | inf_div;	// @[FDIV.scala:266:{27,77}, :272:40, :273:59, :282:88, Reg.scala:19:16]
  wire [5:0]  _GEN_3 = subRes ? subResBits[5:0] : 6'h19;	// @[FDIV.scala:266:27, :268:79, :288:26]
  wire [7:0]  resExp = subResReg ? 8'h0 : finalExp[7:0] + 8'h7F;	// @[Bitwise.scala:77:12, FDIV.scala:264:21, :327:{19,45}, Reg.scala:19:16]
  wire        _noZero_T = rmReg == 3'h2;	// @[FDIV.scala:335:40, OneHot.scala:64:12, Reg.scala:19:16]
  wire        _noZero_T_2 = rmReg == 3'h3;	// @[FDIV.scala:335:74, OneHot.scala:64:12, Reg.scala:19:16]
  wire        noInf = (rmReg == 3'h1 | _noZero_T & ~resSignReg | _noZero_T_2 & resSignReg) & special_fflags[2];	// @[FDIV.scala:335:{22,40,48,51,64,74,82,98,115}, OneHot.scala:64:12, Reg.scala:19:16]
  wire        _combinedSig_T = noInf | (_noZero_T & resSignReg | _noZero_T_2 & ~resSignReg) & special_fflags[1];	// @[FDIV.scala:335:{40,51,74,98}, :336:{32,47,65,82,99}, :340:31, Reg.scala:19:16]
  wire        decode_a_isSNaN = decode_a_isNaN & ~(io_a[22]);	// @[package.scala:48:40, :49:{37,40,49}]
  wire [4:0]  _GEN_4 = _GEN_3[4:0] - 5'h1;	// @[FDIV.scala:288:26, :294:49]
  always @(posedge clock) begin
    if (reset) begin
      state <= 6'h1;	// @[FDIV.scala:172:22]
      outValidReg <= 1'h0;	// @[FDIV.scala:173:28]
    end
    else begin
      if (_T_2) begin	// @[FDIV.scala:207:29]
        if (decode_a_isSubnormal | ~io_specialIO_isSqrt & decode_b_isSubnormal)	// @[FDIV.scala:198:{27,31,37}, package.scala:45:46]
          state <= 6'h2;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
        else	// @[FDIV.scala:198:27]
          state <= 6'h4;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
      end
      else if (state[1])	// @[FDIV.scala:172:22, :209:20]
        state <= 6'h4;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
      else if (state[2]) begin	// @[FDIV.scala:172:22, :211:20]
        if (skipIter)	// @[FDIV.scala:282:88]
          state <= 6'h10;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
        else	// @[FDIV.scala:282:88]
          state <= 6'h8;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
      end
      else if (_T_9)	// @[FDIV.scala:214:25]
        state <= 6'h10;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
      else if (_T_12)	// @[FDIV.scala:217:31]
        state <= 6'h20;	// @[FDIV.scala:172:22, OneHot.scala:64:27]
      else if (state[5])	// @[FDIV.scala:172:22, :220:20, OneHot.scala:64:12]
        state <= 6'h1;	// @[FDIV.scala:172:22]
      if (~(_T_2 | state[1])) begin	// @[FDIV.scala:172:22, :173:28, :207:{29,41}, :209:{20,31}, :211:31]
        if (state[2])	// @[FDIV.scala:172:22, :211:20]
          outValidReg <= skipIter;	// @[FDIV.scala:173:28, :282:88]
        else	// @[FDIV.scala:211:20]
          outValidReg <= _T_9 | ~_T_12 & outValidReg;	// @[FDIV.scala:173:28, :214:{25,43}, :216:17, :217:{31,45}, :219:17]
      end
    end
    if (state[0])	// @[FDIV.scala:172:22, :196:38]
      aSubReg <= decode_a_isSubnormal;	// @[Reg.scala:19:16, package.scala:45:46]
    if (state[0])	// @[FDIV.scala:172:22, :197:38]
      dSubReg <= decode_b_isSubnormal;	// @[Reg.scala:19:16, package.scala:45:46]
    if (state[0])	// @[FDIV.scala:172:22, :199:40]
      sqrtReg <= io_specialIO_isSqrt;	// @[Reg.scala:19:16]
    if (state[0])	// @[FDIV.scala:172:22, :200:37]
      rmReg <= io_rm;	// @[Reg.scala:19:16]
    if (state[0]) begin	// @[FDIV.scala:172:22, :201:99]
      if (io_specialIO_isSqrt)
        resSignReg <= decode_a_isZero & io_a[31];	// @[FDIV.scala:201:43, Reg.scala:19:16, package.scala:47:41, :63:19]
      else
        resSignReg <= io_a[31] ^ io_b[31];	// @[FDIV.scala:201:84, Reg.scala:19:16, package.scala:63:19]
    end
    if (state[0] | state[1]) begin	// @[FDIV.scala:172:22, :229:{73,82,90}]
      if (state[0])	// @[FDIV.scala:172:22, :229:36]
        aSigReg <= {|(io_a[30:23]), io_a[22:0]};	// @[Cat.scala:33:92, Reg.scala:19:16, package.scala:36:31, :64:18, :65:18]
      else	// @[FDIV.scala:229:36]
        aSigReg <= _aSigNorm_T[23:0];	// @[FDIV.scala:239:{12,23}, Reg.scala:19:16]
    end
    if (state[0] | state[1]) begin	// @[FDIV.scala:172:22, :231:{73,82,90}]
      if (state[0])	// @[FDIV.scala:172:22, :231:36]
        dSigReg <= {|(io_b[30:23]), io_b[22:0]};	// @[Cat.scala:33:92, Reg.scala:19:16, package.scala:36:31, :64:18, :65:18]
      else	// @[FDIV.scala:231:36]
        dSigReg <= _dSigNorm_T[23:0];	// @[FDIV.scala:241:{12,23}, Reg.scala:19:16]
    end
    if (state[0] | state[1] & aSubReg) begin	// @[FDIV.scala:172:22, :235:{69,78,87,97}, Reg.scala:19:16]
      if (state[0])	// @[FDIV.scala:172:22, :235:33]
        aExp <= {1'h0, io_a[30:23] | {7'h0, ~(|(io_a[30:23]))}};	// @[FDIV.scala:235:27, Reg.scala:19:16, package.scala:36:31, :64:18, :96:{27,29}]
      else	// @[FDIV.scala:235:33]
        aExp <= aExp - {4'h0, _aLZC_clz_io_out};	// @[CLZ.scala:23:21, FDIV.scala:217:20, :242:19, OneHot.scala:64:12, Reg.scala:19:16]
    end
    if (state[0] | state[1] & dSubReg) begin	// @[FDIV.scala:172:22, :237:{69,78,87,97}, Reg.scala:19:16]
      if (state[0])	// @[FDIV.scala:172:22, :237:33]
        dExp <= {1'h0, io_b[30:23] | {7'h0, ~(|(io_b[30:23]))}};	// @[FDIV.scala:237:27, Reg.scala:19:16, package.scala:36:31, :64:18, :96:{27,29}]
      else	// @[FDIV.scala:237:33]
        dExp <= dExp - {4'h0, _dLZC_clz_io_out};	// @[CLZ.scala:23:21, FDIV.scala:217:20, :243:19, OneHot.scala:64:12, Reg.scala:19:16]
    end
    if (state[0]) begin	// @[FDIV.scala:172:22, :249:204]
      if (io_specialIO_isSqrt)
        inv <= io_a[31] & ~decode_a_isZero | decode_a_isNaN;	// @[FDIV.scala:249:{46,49,67}, Reg.scala:19:16, package.scala:47:41, :48:40, :63:19]
      else
        inv <= _inv_flag_T_5 | _inv_flag_T_6 | decode_a_isNaN | decode_b_isNaN;	// @[FDIV.scala:249:{102,141,179}, Reg.scala:19:16, package.scala:48:40]
    end
    if (state[0]) begin	// @[FDIV.scala:172:22, :250:235]
      if (io_specialIO_isSqrt)
        inv_flag <= io_a[31] & ~(decode_a_isNaN & io_a[22]) & ~decode_a_isZero | decode_a_isSNaN;	// @[FDIV.scala:249:49, :250:{54,70,91}, Reg.scala:19:16, package.scala:47:41, :48:40, :49:{37,49}, :50:37, :63:19]
      else
        inv_flag <= _inv_flag_T_5 | _inv_flag_T_6 | decode_a_isSNaN | decode_b_isNaN & ~(io_b[22]);	// @[FDIV.scala:249:{102,141}, :250:207, Reg.scala:19:16, package.scala:48:40, :49:{37,40,49}]
    end
    if (state[0])	// @[FDIV.scala:172:22, :251:75]
      dz <= decode_b_isZero & ~decode_a_isZero & ~io_specialIO_isSqrt;	// @[FDIV.scala:249:49, :251:{58,61}, Reg.scala:19:16, package.scala:47:41]
    if (state[0])	// @[FDIV.scala:172:22, :252:82]
      zero_div <= decode_a_isZero & (~decode_b_isZero | io_specialIO_isSqrt);	// @[FDIV.scala:252:{44,48,65}, Reg.scala:19:16, package.scala:47:41]
    if (state[0])	// @[FDIV.scala:172:22, :253:78]
      div_inf <= ~io_specialIO_isSqrt & decode_b_isInf & ~decode_a_isInf;	// @[FDIV.scala:251:61, :253:{53,56}, Reg.scala:19:16, package.scala:46:40]
    if (state[0])	// @[FDIV.scala:172:22, :254:96]
      inf_div <= (io_specialIO_isSqrt | ~decode_b_isInf) & decode_a_isInf;	// @[FDIV.scala:254:{30,73}, Reg.scala:19:16, package.scala:46:40]
    if (state[2])	// @[FDIV.scala:172:22, :270:42]
      subResReg <= subRes;	// @[FDIV.scala:268:79, Reg.scala:19:16]
    if (state[2])	// @[FDIV.scala:172:22, :276:116]
      special_fflags <= {inv_flag, dz & ~inv & ~inf_div, overflow, underflow_pre, ~zero_div & ~inv & ~dz & ~div_inf & ~inf_div};	// @[Cat.scala:33:92, FDIV.scala:272:{28,36,40,43}, :273:{49,59,62}, :274:58, :276:59, Reg.scala:19:16]
    if (state[2])	// @[FDIV.scala:172:22, :278:116]
      special_exp <= {8{inv | overflow | dz | inf_div}};	// @[FDIV.scala:272:40, :278:{34,57}, Reg.scala:19:16]
    if (state[2])	// @[FDIV.scala:172:22, :279:85]
      special_sig <= {inv, 22'h0};	// @[FDIV.scala:279:34, Reg.scala:19:16]
    if (state[2])	// @[FDIV.scala:172:22, :283:46]
      skipIterReg <= skipIter;	// @[FDIV.scala:282:88, Reg.scala:19:16]
    if (state[2])	// @[FDIV.scala:172:22, :291:48]
      needShiftReg <= sqrtReg ^ ~(_GEN_3[0]);	// @[FDIV.scala:288:26, :290:{22,45}, Reg.scala:19:16]
    if (state[2])	// @[FDIV.scala:172:22, :292:54]
      oddIterReg <= ~(_GEN_3[1]);	// @[FDIV.scala:288:26, :292:{30,44}, Reg.scala:19:16]
    if (state[2] | state[3])	// @[FDIV.scala:172:22, :295:{44,54,62}]
      iterNumReg <= state[2] ? (sqrtReg ? _GEN_4[4:1] : _GEN_3[5:2]) : iterNumReg - 4'h1;	// @[FDIV.scala:172:22, :288:26, :294:{24,49,55}, :296:{17,23,58}, Reg.scala:19:16]
    if (state[4]) begin	// @[FDIV.scala:172:22, :346:52]
      if (_combinedSig_T) begin	// @[FDIV.scala:340:31]
        if (noInf)	// @[FDIV.scala:335:98]
          combinedExpReg <= 8'hFE;	// @[FDIV.scala:338:25, Reg.scala:19:16]
        else	// @[FDIV.scala:335:98]
          combinedExpReg <= 8'h0;	// @[Bitwise.scala:77:12, Reg.scala:19:16]
      end
      else if (skipIterReg)	// @[Reg.scala:19:16]
        combinedExpReg <= special_exp;	// @[Reg.scala:19:16]
      else if (_rounder_io_cout & resExp != 8'hFE)	// @[FDIV.scala:320:23, :327:19, :338:25, :342:{27,38}]
        combinedExpReg <= resExp + 8'h1;	// @[FDIV.scala:327:19, :342:85, Reg.scala:19:16]
      else	// @[FDIV.scala:342:27]
        combinedExpReg <= resExp;	// @[FDIV.scala:327:19, Reg.scala:19:16]
    end
    if (state[4]) begin	// @[FDIV.scala:172:22, :347:52]
      if (_combinedSig_T) begin	// @[FDIV.scala:340:31]
        if (noInf)	// @[FDIV.scala:335:98]
          combinedSigReg <= 23'h7FFFFF;	// @[Bitwise.scala:77:12, Reg.scala:19:16]
        else	// @[FDIV.scala:335:98]
          combinedSigReg <= 23'h1;	// @[FDIV.scala:337:25, Reg.scala:19:16]
      end
      else if (skipIterReg)	// @[Reg.scala:19:16]
        combinedSigReg <= special_sig;	// @[Reg.scala:19:16]
      else if (_rounder_io_cout & resExp == 8'hFE) begin	// @[FDIV.scala:320:23, :327:19, :338:25, :345:{27,38}]
        if (needShiftReg)	// @[Reg.scala:19:16]
          combinedSigReg <= _GEN[24:2];	// @[FDIV.scala:317:19, :321:44, Reg.scala:19:16]
        else	// @[Reg.scala:19:16]
          combinedSigReg <= _GEN[23:1];	// @[FDIV.scala:317:19, :321:66, Reg.scala:19:16]
      end
      else	// @[FDIV.scala:345:27]
        combinedSigReg <= _rounder_io_out;	// @[FDIV.scala:320:23, Reg.scala:19:16]
    end
    if (state[4]) begin	// @[FDIV.scala:172:22, :348:58]
      if (skipIterReg)	// @[Reg.scala:19:16]
        combinedFFlagsReg <= special_fflags;	// @[Reg.scala:19:16]
      else	// @[Reg.scala:19:16]
        combinedFFlagsReg <= {2'h0, &resExp, resExp == 8'h0 & _rounder_io_inexact, _rounder_io_inexact};	// @[Bitwise.scala:77:12, Cat.scala:33:92, FDIV.scala:320:23, :327:19, :329:{20,24}, :330:19, Reg.scala:19:16]
    end
    if (state[4])	// @[FDIV.scala:172:22, :349:71]
      combinedSignReg <= ~inv & resSignReg;	// @[FDIV.scala:277:35, Reg.scala:19:16]
  end // always @(posedge)
  `ifndef SYNTHESIS
    always @(posedge clock) begin	// @[FDIV.scala:226:9]
      if (~reset & outValidReg != state[4]) begin	// @[FDIV.scala:172:22, :173:28, :226:{9,22,31}]
        if (`ASSERT_VERBOSE_COND_)	// @[FDIV.scala:226:9]
          $error("Assertion failed\n    at FDIV.scala:226 assert(outValidReg === state(s_post_0))\n");	// @[FDIV.scala:226:9]
        if (`STOP_COND_)	// @[FDIV.scala:226:9]
          $fatal;	// @[FDIV.scala:226:9]
      end
    end // always @(posedge)
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;
    logic [31:0] _RANDOM_1;
    logic [31:0] _RANDOM_2;
    logic [31:0] _RANDOM_3;
    logic [31:0] _RANDOM_4;
    logic [31:0] _RANDOM_5;
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM_0 = `RANDOM;
        _RANDOM_1 = `RANDOM;
        _RANDOM_2 = `RANDOM;
        _RANDOM_3 = `RANDOM;
        _RANDOM_4 = `RANDOM;
        _RANDOM_5 = `RANDOM;
        state = _RANDOM_0[5:0];	// @[FDIV.scala:172:22]
        outValidReg = _RANDOM_0[6];	// @[FDIV.scala:172:22, :173:28]
        aSubReg = _RANDOM_0[7];	// @[FDIV.scala:172:22, Reg.scala:19:16]
        dSubReg = _RANDOM_0[8];	// @[FDIV.scala:172:22, Reg.scala:19:16]
        sqrtReg = _RANDOM_0[9];	// @[FDIV.scala:172:22, Reg.scala:19:16]
        rmReg = _RANDOM_0[12:10];	// @[FDIV.scala:172:22, Reg.scala:19:16]
        resSignReg = _RANDOM_0[13];	// @[FDIV.scala:172:22, Reg.scala:19:16]
        aSigReg = {_RANDOM_0[31:14], _RANDOM_1[5:0]};	// @[FDIV.scala:172:22, Reg.scala:19:16]
        dSigReg = _RANDOM_1[29:6];	// @[Reg.scala:19:16]
        aExp = {_RANDOM_1[31:30], _RANDOM_2[6:0]};	// @[Reg.scala:19:16]
        dExp = _RANDOM_2[15:7];	// @[Reg.scala:19:16]
        inv = _RANDOM_2[16];	// @[Reg.scala:19:16]
        inv_flag = _RANDOM_2[17];	// @[Reg.scala:19:16]
        dz = _RANDOM_2[18];	// @[Reg.scala:19:16]
        zero_div = _RANDOM_2[19];	// @[Reg.scala:19:16]
        div_inf = _RANDOM_2[20];	// @[Reg.scala:19:16]
        inf_div = _RANDOM_2[21];	// @[Reg.scala:19:16]
        subResReg = _RANDOM_2[22];	// @[Reg.scala:19:16]
        special_fflags = _RANDOM_2[27:23];	// @[Reg.scala:19:16]
        special_exp = {_RANDOM_2[31:29], _RANDOM_3[4:0]};	// @[Reg.scala:19:16]
        special_sig = _RANDOM_3[27:5];	// @[Reg.scala:19:16]
        skipIterReg = _RANDOM_3[28];	// @[Reg.scala:19:16]
        needShiftReg = _RANDOM_4[7];	// @[Reg.scala:19:16]
        oddIterReg = _RANDOM_4[8];	// @[Reg.scala:19:16]
        iterNumReg = _RANDOM_4[12:9];	// @[Reg.scala:19:16]
        combinedExpReg = _RANDOM_4[20:13];	// @[Reg.scala:19:16]
        combinedSigReg = {_RANDOM_4[31:21], _RANDOM_5[11:0]};	// @[Reg.scala:19:16]
        combinedFFlagsReg = _RANDOM_5[16:12];	// @[Reg.scala:19:16]
        combinedSignReg = _RANDOM_5[17];	// @[Reg.scala:19:16]
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  CLZ aLZC_clz (	// @[CLZ.scala:23:21]
    .io_in  (aSigReg),	// @[Reg.scala:19:16]
    .io_out (_aLZC_clz_io_out)
  );
  CLZ dLZC_clz (	// @[CLZ.scala:23:21]
    .io_in  (dSigReg),	// @[Reg.scala:19:16]
    .io_out (_dLZC_clz_io_out)
  );
  DivIterModule divModule (	// @[FDIV.scala:300:25]
    .clock             (clock),
    .io_a              (aSigReg),	// @[Reg.scala:19:16]
    .io_d              (dSigReg),	// @[Reg.scala:19:16]
    .io_state          (state[3:2]),	// @[Cat.scala:33:92, FDIV.scala:172:22]
    .io_lastIterDoHalf (oddIterReg & finalIter),	// @[FDIV.scala:297:27, :304:45, Reg.scala:19:16]
    .io_sigCmp         (sigCmp),	// @[FDIV.scala:259:24]
    .io_rem            (_divModule_io_rem),
    .io_quot           (_divModule_io_quot),
    .io_quotM1         (_divModule_io_quotM1)
  );
  SqrtIterModule sqrtModule (	// @[FDIV.scala:307:26]
    .clock    (clock),
    .io_a     (aExp[0] ? {1'h0, aSigReg} : {aSigReg, 1'h0}),	// @[Cat.scala:33:92, FDIV.scala:262:24, :308:25, Reg.scala:19:16]
    .io_state (state[3:2]),	// @[Cat.scala:33:92, FDIV.scala:172:22]
    .io_rem   (_sqrtModule_io_rem),
    .io_res   (_sqrtModule_io_res),
    .io_resM1 (_sqrtModule_io_resM1)
  );
  RoundingUnit rounder (	// @[FDIV.scala:320:23]
    .io_in       (needShiftReg ? _GEN[24:2] : _GEN[23:1]),	// @[FDIV.scala:317:19, :321:{23,44,66}, Reg.scala:19:16]
    .io_roundIn  (needShiftReg ? _GEN[1] : _GEN[0]),	// @[FDIV.scala:317:19, :318:52, :319:{18,39}, Reg.scala:19:16]
    .io_stickyIn ((|r) | needShiftReg & _GEN[0]),	// @[FDIV.scala:316:14, :317:19, :318:{22,26,43,52}, Reg.scala:19:16]
    .io_signIn   (resSignReg),	// @[Reg.scala:19:16]
    .io_rm       (rmReg),	// @[Reg.scala:19:16]
    .io_out      (_rounder_io_out),
    .io_inexact  (_rounder_io_inexact),
    .io_cout     (_rounder_io_cout)
  );
  assign io_result = {combinedSignReg, combinedExpReg, combinedSigReg};	// @[Cat.scala:33:92, Reg.scala:19:16]
  assign io_fflags = combinedFFlagsReg;	// @[Reg.scala:19:16]
  assign io_specialIO_in_ready = state[0];	// @[FDIV.scala:172:22, :176:20]
  assign io_specialIO_out_valid = outValidReg;	// @[FDIV.scala:173:28]
endmodule

